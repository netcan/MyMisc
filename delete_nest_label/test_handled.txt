<BEGIN_E>python<END_E>[1] （英国发音：/ˈpaɪθən/
是一种面向对象的解释型<BEGIN_E>计算机程序设计语言<END_E>
<BEGIN_E>python<END_E>是纯粹的<BEGIN_E>自由软件<END_E>
<BEGIN_E>源代码<END_E>和<BEGIN_E>解释器<END_E>C<BEGIN_E>python<END_E>遵循
<BEGIN_E>GPL<END_E>(<BEGIN_E>GNU<END_E>
<BEGIN_E>python<END_E>语法简洁清晰
<BEGIN_E>python<END_E>具有丰富和强大的库
它常被昵称为<BEGIN_E>胶水语言<END_E>
能够把用其他语言制作的各种模块（尤其是<BEGIN_E>C<END_E>/<BEGIN_E>C++<END_E>）很轻松地联结在一起
使用<BEGIN_E>python<END_E>快速生成程序的原型（有时甚至是程序的最终界面）
比如<BEGIN_E>3D游戏<END_E>中的图形渲染模块
而后封装为<BEGIN_E>python<END_E>可以调用的扩展类库
某些可能不提供<BEGIN_E>跨平台<END_E>的实现
IEEE发布2017年编程语言排行榜：<BEGIN_E>python<END_E>高居首位[4] 
自从20世纪90年代初<BEGIN_E>python<END_E>语言诞生至今
它已被逐渐广泛应用于系统管理任务的处理和<BEGIN_E>Web<END_E>编程
<BEGIN_E>python<END_E>的创始人为Guido
在<BEGIN_E>阿姆斯特丹<END_E>
之所以选中<BEGIN_E>python<END_E>（大蟒蛇的意思）作为该编程语言的名字
<BEGIN_E>python<END_E>的喜剧团体的<BEGIN_E>爱好者<END_E>
ABC是由Guido参加设计的一种<BEGIN_E>教学<END_E>语言
决心在<BEGIN_E>python<END_E>
<BEGIN_E>python<END_E>在Guido手中诞生了
<BEGIN_E>python<END_E>是从ABC发展起来
<BEGIN_E>python<END_E>[6] 已经成为最受欢迎的程序设计语言之一
它被<BEGIN_E>TIOBE<END_E>编程语言排行榜评为2010年度语言
<BEGIN_E>python<END_E>的使用率呈线性增长[7] 
由于<BEGIN_E>python<END_E>语言的<BEGIN_E>简洁<END_E>性、易读性以及可扩展性
在国外用<BEGIN_E>python<END_E>做科学计算的研究机构日益增多
一些知名大学已经采用<BEGIN_E>python<END_E>来教授程序设计<BEGIN_E>课程<END_E>
例如<BEGIN_E>卡耐基梅隆大学<END_E>的编程基础、麻省理工学院的计算机科学及编程导论就使用<BEGIN_E>python<END_E>语言讲授
众多开源的科学计算软件包都提供了<BEGIN_E>python<END_E>的调用<BEGIN_E>接口<END_E>
例如著名的计算机视觉库<BEGIN_E>OpenCV<END_E>、三维可视化库VTK、医学图像处理库ITK
而<BEGIN_E>python<END_E>专用的科学计算扩展库就更多了
它们分别为<BEGIN_E>python<END_E>提供了快速数组处理、数值运算以及绘图功能
因此<BEGIN_E>python<END_E>语言及其众多的扩展库所构成的开发环境十分适合<BEGIN_E>工程<END_E>技术、科研人员处理实验数据、制作图表
甚至开发科学计算<BEGIN_E>应用程序<END_E>
<BEGIN_E>python<END_E>在设计上坚持了清晰划一的风格
这使得<BEGIN_E>python<END_E>成为一门易读、易维护
Peters写的<BEGIN_E>python<END_E>格言（称为The
<BEGIN_E>python<END_E>）里面表述为：There
这正好和<BEGIN_E>Perl<END_E>语言（另一种功能类似的高级<BEGIN_E>动态语言<END_E>）的中心思想TMTOWTDI（There's
<BEGIN_E>python<END_E>的作者有意的设计限制性很强的语法
使得不好的编程习惯（例如<BEGIN_E>if语句<END_E>的下一行不向右缩进）都不能通过编译
其中很重要的一项就是<BEGIN_E>python<END_E>的缩进规则
完全是由每行的首字符在这一行的位置来决定的（而C语言是用一对花括号<BEGIN_E>{}<END_E>来明确的定出模块的边界的
通过强制程序员们<BEGIN_E>缩进<END_E>（包括if
<BEGIN_E>python<END_E>确实使得程序更加清晰和美观
首先会被提到的可能是<BEGIN_E>MATLAB<END_E>
MATLAB的大部分常用功能都可以在<BEGIN_E>python<END_E>世界中找到相应的扩展库
用<BEGIN_E>python<END_E>做科学计算有如下优点：
而<BEGIN_E>python<END_E>完全免费
众多开源的<BEGIN_E>科学<END_E>计算库都提供了<BEGIN_E>python<END_E>的调用接口
用户可以在任何计算机上免费安装<BEGIN_E>python<END_E>及其绝大多数扩展库
<BEGIN_E>python<END_E>是一门更易学、更严谨的程序设计语言
也经常会遇到文件管理、<BEGIN_E>界面设计<END_E>、<BEGIN_E>网络通信<END_E>等各种需求
而<BEGIN_E>python<END_E>有着丰富的扩展库
开发者可以用<BEGIN_E>python<END_E>实现完整应用程序所需的各种功能
<BEGIN_E>python<END_E>的设计哲学是“优雅”、“明确”、“简单”
Perl语言中“总是有多种方法来做同一件事”的理念在<BEGIN_E>python<END_E>开发者中通常是难以忍受的
<BEGIN_E>python<END_E>开发者的哲学是“用一种方法
在设计<BEGIN_E>python<END_E>语言时
<BEGIN_E>python<END_E>开发者一般会拒绝花俏的语法
<BEGIN_E>python<END_E>源代码通常被认为比Perl具备更好的可读性
这些准则被称为<BEGIN_E>python<END_E>格言
在<BEGIN_E>python<END_E><BEGIN_E>解释器<END_E>内运行import
<BEGIN_E>python<END_E>开发人员尽量避开不成熟或者不重要的优化
一些针对非重要部位的加快运行速度的补丁通常不会被合并到<BEGIN_E>python<END_E>内
所以很多人认为<BEGIN_E>python<END_E>很慢
<BEGIN_E>python<END_E>设计师倾向于使用<BEGIN_E>JIT<END_E>技术
可用的JIT技术是<BEGIN_E>PyPy<END_E>
<BEGIN_E>python<END_E>是完全面向对象的语言
<BEGIN_E>python<END_E>支持重载运算符和动态类型
相对于<BEGIN_E>Lisp<END_E>这种传统的函数式编程语言
<BEGIN_E>python<END_E>对函数式设计只提供了有限的支持
itertools)提供了<BEGIN_E>Haskell<END_E>和Standard
虽然<BEGIN_E>python<END_E>可能被粗略地分类为“<BEGIN_E>脚本语言<END_E>”（script
但实际上一些大规模软件开发计划例如<BEGIN_E>Zope<END_E>、<BEGIN_E>Mnet<END_E>及BitTorrent
<BEGIN_E>python<END_E>的支持者较喜欢称它为一种高级动态编程语言
如shellscript、<BEGIN_E>VBScript<END_E>等只能处理简单任务的编程语言
并不能与<BEGIN_E>python<END_E>相提并论
<BEGIN_E>python<END_E>本身被设计为可扩充的
<BEGIN_E>python<END_E>提供了丰富的<BEGIN_E>API<END_E>和工具
<BEGIN_E>python<END_E>编译器本身也可以被集成到其它需要脚本语言的程序内
很多人还把<BEGIN_E>python<END_E>作为一种“胶水语言”（glue
使用<BEGIN_E>python<END_E>将其他语言编写的程序进行集成和封装
然后用<BEGIN_E>python<END_E>或Java/Go调用相应的模块
《<BEGIN_E>python技术手册<END_E>》的作者<BEGIN_E>马特利<END_E>（Alex
<BEGIN_E>python<END_E>
已在<BEGIN_E>Google<END_E>
<BEGIN_E>python<END_E>
但在这之前就已决定使用<BEGIN_E>python<END_E>
<BEGIN_E>python<END_E>
<BEGIN_E>python<END_E>
<BEGIN_E>python<END_E>在执行时
首先会将.py文件中的<BEGIN_E>源代码<END_E>编译成<BEGIN_E>python<END_E>的byte
然后再由<BEGIN_E>python<END_E>
Machine（<BEGIN_E>python<END_E><BEGIN_E>虚拟机<END_E>）来执行这些编译好的byte
<BEGIN_E>python<END_E>
<BEGIN_E>python<END_E>的Virtual
不是说<BEGIN_E>python<END_E>的Virtual
<BEGIN_E>python<END_E>的Virtual
<BEGIN_E>python<END_E>的Virtual
基于C的<BEGIN_E>python<END_E>编译出的<BEGIN_E>字节码<END_E>文件
<BEGIN_E>python<END_E>还可以以交互模式运行
比如主流操作系统Unix/Linux、Mac、Windows都可以直接在命令模式下直接运行<BEGIN_E>python<END_E>交互环境
<BEGIN_E>python<END_E>的设计目标之一是让代码具备高度的可阅读性
<BEGIN_E>python<END_E>开发者有意让违反了缩进规则的程序不能通过编译
并且<BEGIN_E>python<END_E>语言利用缩进表示语句块的开始和退出（Off-side规则）
<BEGIN_E>python<END_E>3
支持Tab字符和其它数目的空格仅仅是为兼容很旧的的<BEGIN_E>python<END_E>程序和某些有问题的编辑程序
遍历列表、字符串、字典、集合等<BEGIN_E>迭代器<END_E>
用于定义<BEGIN_E>类型<END_E>
<BEGIN_E>python<END_E>2.6以后定义的语法
自从<BEGIN_E>python<END_E>
<BEGIN_E>python<END_E>的表达式写法与C/C++类似
<BEGIN_E>python<END_E>使用and
<BEGIN_E>python<END_E>支持“列表推导式”（list
<BEGIN_E>python<END_E>使用lambda表示匿名函数
<BEGIN_E>python<END_E>使用y
<BEGIN_E>python<END_E>区分列表(list)和元组(tuple)两种类型
<BEGIN_E>python<END_E>使用'(单引号)和"(双引号)来表示字符串
表达式前加r指示<BEGIN_E>python<END_E>不解释字符串中出现的\
<BEGIN_E>python<END_E>支持列表切割(list
<BEGIN_E>python<END_E>的函数支持递归、默认参数值、可变参数
<BEGIN_E>python<END_E>认识一些以“__”开始并以“__”结束的特殊方法名
<BEGIN_E>python<END_E>采用动态类型系统
<BEGIN_E>python<END_E>不会检查对象是否拥有被调用的方法或者属性
虽然<BEGIN_E>python<END_E>采用动态类型系统
<BEGIN_E>python<END_E>禁止没有明确定义的操作
<BEGIN_E>python<END_E>允许程序员定义类型
<BEGIN_E>python<END_E>内置丰富的数据类型
下面这个列表简要地描述了<BEGIN_E>python<END_E>内置数据类型(适用于<BEGIN_E>python<END_E>
<BEGIN_E>str<END_E>
<BEGIN_E>python<END_E>语言还用类型来表示函数、模块、类型本身、对象的方法、编译后的<BEGIN_E>python<END_E>代码、运行时信息等等
<BEGIN_E>python<END_E>具备很强的动态性
<BEGIN_E>python<END_E>使用与C、Java类似的运算符
<BEGIN_E>python<END_E>定义求余运行a
<BEGIN_E>python<END_E>允许像数学的常用写法那样连着写两个比较运行符
C++的结果与<BEGIN_E>python<END_E>不一样
)开头的名称用于较复杂的<BEGIN_E>python<END_E>编程
查看完整的<BEGIN_E>python<END_E>内置函数清单
CGI程序可以是<BEGIN_E>python<END_E>脚本、Perl脚本、Shell脚本、C或者C++程序等
<BEGIN_E>python<END_E>也可以使用.py扩展名
使用<BEGIN_E>python<END_E>创建第一个CGI程序
这个的hello.py脚本是一个简单的<BEGIN_E>python<END_E>脚本
简单：<BEGIN_E>python<END_E>是一种代表简单主义思想的语言
阅读一个良好的<BEGIN_E>python<END_E>程序就感觉像是在读英语一样
易学：<BEGIN_E>python<END_E>极其容易上手
因为<BEGIN_E>python<END_E>有极其简单的说明文档[8] 
速度快：<BEGIN_E>python<END_E>
免费、开源：<BEGIN_E>python<END_E>是<BEGIN_E>FLOSS<END_E>（自由/<BEGIN_E>开放源码<END_E>软件）之一
使用者可以自由地发布这个软件的拷贝、阅读它的<BEGIN_E>源代码<END_E>、对它做改动、把它的一部分用于新的自由软件中
高层语言：用<BEGIN_E>python<END_E>语言编写程序的时候无需考虑诸如如何管理你的程序使用的内存一类的底层细节
<BEGIN_E>python<END_E>已经被移植在许多平台上（经过改动使它能够工作在不同平台上）
解释性：一个用编译性语言比如C或C++写的程序可以从<BEGIN_E>源文件<END_E>（即C或C++语言）转换到一个你的计算机使用的语言（<BEGIN_E>二进制代码<END_E>
这个过程通过<BEGIN_E>编译器<END_E>和不同的标记、选项完成
而<BEGIN_E>python<END_E>语言写的程序不需要编译成二进制代码
你可以直接从<BEGIN_E>源代码<END_E>运行
<BEGIN_E>python<END_E><BEGIN_E>解释器<END_E>把源代码转换成称为<BEGIN_E>字节码<END_E>的中间形式
然后再把它翻译成计算机使用的<BEGIN_E>机器语言<END_E>并运行
这使得使用<BEGIN_E>python<END_E>更加简单
也使得<BEGIN_E>python<END_E>程序更加易于移植
<BEGIN_E>面向对象<END_E>：<BEGIN_E>python<END_E>既支持<BEGIN_E>面向过程<END_E>的编程也支持面向对象的编程
在“<BEGIN_E>面向对象<END_E>”的语言中
然后在<BEGIN_E>python<END_E>程序中使用它们
可嵌入性：可以把<BEGIN_E>python<END_E>嵌入C/C++程序
丰富的库：<BEGIN_E>python<END_E>标准库确实很庞大
包括<BEGIN_E>正则表达式<END_E>、文档生成、<BEGIN_E>单元测试<END_E>、<BEGIN_E>线程<END_E>、数据库、网页浏览器、CGI、FTP、电子邮件、XML、XML-RPC、HTML、WAV文件、密码系统、GUI（<BEGIN_E>图形用户界面<END_E>）、Tk和其他与系统有关的操作
这被称作<BEGIN_E>python<END_E>的“功能齐全”理念
如wx<BEGIN_E>python<END_E>、Twisted和<BEGIN_E>python<END_E>图像库等等
规范的代码：<BEGIN_E>python<END_E>采用强制缩进的方式使得代码具有较好可读性
而<BEGIN_E>python<END_E>语言写的程序不需要编译成二进制代码
<BEGIN_E>单行语句和命令行输出问题<END_E>：很多时候不能将程序连写成一行
不需要如<BEGIN_E>python<END_E>一样
即便是很有经验的<BEGIN_E>python<END_E>程序员
系统编程：提供<BEGIN_E>API<END_E>（<BEGIN_E>Application
图形处理：有PIL、<BEGIN_E>Tkinter<END_E>等图形库支持
文本处理：<BEGIN_E>python<END_E>提供的re模块能支持<BEGIN_E>正则表达式<END_E>
还提供<BEGIN_E>SGML<END_E>
<BEGIN_E>XML<END_E>分析模块
许多程序员利用<BEGIN_E>python<END_E>进行XML程序的开发
数据库编程：程序员可通过遵循<BEGIN_E>python<END_E>
DB-API（数据库<BEGIN_E>应用程序编程接口<END_E>）规范的模块与Microsoft
<BEGIN_E>python<END_E>自带有一个Gadfly模块
<BEGIN_E>网络编程<END_E>：提供丰富的模块支持sockets编程
能方便快速地开发<BEGIN_E>分布式应用程序<END_E>
很多大规模软件开发计划例如<BEGIN_E>Zope<END_E>
及<BEGIN_E>BitTorrent<END_E>.
多媒体应用：<BEGIN_E>python<END_E>的PyOpenGL模块封装了“OpenGL应用程序编程接口”
能进行二维和三维<BEGIN_E>图像处理<END_E>
pymo引擎：PYMO全称为<BEGIN_E>python<END_E>
因其基于<BEGIN_E>python<END_E>2.0平台开发
并且适用于创建<BEGIN_E>秋之回忆<END_E>（<BEGIN_E>memories
黑客编程：<BEGIN_E>python<END_E>有一个hack的库
用<BEGIN_E>python<END_E>写简单爬虫
要通过urllib2这个Module获得对应的<BEGIN_E>HTML<END_E>源码
(PS:在<BEGIN_E>python<END_E>3.3之后urllib2已经不能再用
<BEGIN_E>python<END_E>默认的图形界面接口
Tkinter是一个和Tk接口的<BEGIN_E>python<END_E>模块
<BEGIN_E>PyGTK<END_E>
用于<BEGIN_E>python<END_E>
<BEGIN_E>PyQt<END_E>
用于<BEGIN_E>python<END_E>的Qt开发库
<BEGIN_E>wxpython<END_E>
Constructor可以方便迅速的进行wx<BEGIN_E>python<END_E>的开发）
<BEGIN_E>PIL<END_E>
<BEGIN_E>python<END_E>提供强大的图形处理的能力
是<BEGIN_E>python<END_E>用户进行图象处理的强有力工具
一个<BEGIN_E>python<END_E>代码加速度器
可使<BEGIN_E>python<END_E>代码的执行速度提高到与编译语言一样的水平
在<BEGIN_E>python<END_E>中有一个xmpppy模块支持该协议
用于多媒体操作的<BEGIN_E>python<END_E>模块
<BEGIN_E>python<END_E>
<BEGIN_E>python<END_E>超级GUI组件集
一个在<BEGIN_E>python<END_E>中利用Tkinter模块构建的高级GUI组件
用<BEGIN_E>python<END_E>解析和处理XML文档的工具包
<BEGIN_E>PyGame<END_E>
通过该模块<BEGIN_E>python<END_E>程序员可在程序中集成2D和3D的图形
NumPy、NumArray、<BEGIN_E>SAGE<END_E>
NumArray是<BEGIN_E>python<END_E>的一个扩展库
<BEGIN_E>MySQLdb<END_E>
<BEGIN_E>python<END_E>-ldap
可方便地在<BEGIN_E>python<END_E>中访问ldap目录服务
OpenCL的<BEGIN_E>python<END_E>接口
<BEGIN_E>python<END_E>拥有一个强大的标准库
<BEGIN_E>python<END_E>语言的核心只包含数字、字符串、列表、字典、文件等常见类型和函数
而由<BEGIN_E>python<END_E>标准库提供了系统管理、网络通信、文本处理、数据库接口、图形系统、XML处理等额外的功能
<BEGIN_E>python<END_E>标准库命名接口清晰、文档良好
<BEGIN_E>python<END_E>社区提供了大量的第三方模块
第三方模块可以使用<BEGIN_E>python<END_E>或者<BEGIN_E>C语言<END_E>编写
<BEGIN_E>SWIG<END_E>
SIP常用于将C语言编写的程序库转化为<BEGIN_E>python<END_E>模块
Boost.<BEGIN_E>python<END_E>
<BEGIN_E>python<END_E>
<BEGIN_E>python<END_E>已成为一种强大的应用于其他语言与工具之间的<BEGIN_E>胶水语言<END_E>
<BEGIN_E>python<END_E>标准库的主要功能有：
●IDLE：<BEGIN_E>python<END_E>内置IDE
(随<BEGIN_E>python<END_E>安装包提供)
●PyCharm[10] ：详见百度百科<BEGIN_E>PyCharm<END_E>
带有一整套可以帮助用户在使用<BEGIN_E>python<END_E>语言开发时提高其效率的工
●<BEGIN_E>python<END_E>Win：<BEGIN_E>Activepython<END_E>或pywin32均提供该IDE
<BEGIN_E>python<END_E>
基于wx<BEGIN_E>python<END_E>
基于wx<BEGIN_E>python<END_E>；作者是中国<BEGIN_E>python<END_E>高手limodou
●WingIDE：可能是功能最全的<BEGIN_E>IDE<END_E>
●Eric：基于<BEGIN_E>PyQt<END_E>的自由软件
<BEGIN_E>python<END_E>
●Dr<BEGIN_E>python<END_E>
●<BEGIN_E>PyScripter<END_E>：使用Delphi开发的轻量级的开源<BEGIN_E>python<END_E>
支持<BEGIN_E>python<END_E>2.6和3.0
●<BEGIN_E>PyPE<END_E>：一个开源的跨平台的<BEGIN_E>python<END_E>IDE
●<BEGIN_E>bpython<END_E>：
类Unix操作系统下使用curses库开发的轻量级的<BEGIN_E>python<END_E><BEGIN_E>解释器<END_E>
pydev<BEGIN_E>插件<END_E>：方便调试程序
●emacs：自带<BEGIN_E>python<END_E>支持
●<BEGIN_E>Vim<END_E>:
最新7.3版编译时可以加入<BEGIN_E>python<END_E>支持
提供<BEGIN_E>python<END_E>代码自动提示支持
Visual<BEGIN_E>python<END_E>：仅适用Windows
●<BEGIN_E>SlickEdit<END_E>
<BEGIN_E>python<END_E>
●<BEGIN_E>TextMate<END_E>
●<BEGIN_E>Sublime<END_E>
●i<BEGIN_E>python<END_E>
诸如<BEGIN_E>Notepad++<END_E>、<BEGIN_E>EditPlus<END_E>、<BEGIN_E>UltraEdit<END_E>等通用的程序员<BEGIN_E>文本编辑器<END_E>软件也能对<BEGIN_E>python<END_E>代码编辑提供一定的支持
但是否够得上<BEGIN_E>集成开发环境<END_E>的水平
<BEGIN_E>python<END_E>是一门跨平台的脚本语言
<BEGIN_E>python<END_E>规定了一个<BEGIN_E>python<END_E>语法规则
实现了<BEGIN_E>python<END_E>语法的解释程序就成为了<BEGIN_E>python<END_E>的<BEGIN_E>解释器<END_E>
C<BEGIN_E>python<END_E>（Classic<BEGIN_E>python<END_E>
也就是原始的<BEGIN_E>python<END_E>实现
需要区别于其他实现的时候才以C<BEGIN_E>python<END_E>称呼；或解作C语言实现的<BEGIN_E>python<END_E>）
这是最常用的<BEGIN_E>python<END_E>版本
<BEGIN_E>Jython<END_E>（原名J<BEGIN_E>python<END_E>；Java语言实现的<BEGIN_E>python<END_E>
<BEGIN_E>PyPy<END_E>（使用<BEGIN_E>python<END_E>语言写的<BEGIN_E>python<END_E>）
<BEGIN_E>Ironpython<END_E>（面向<BEGIN_E>.NET<END_E>和ECMA
CLI的<BEGIN_E>python<END_E>实现）
Iron<BEGIN_E>python<END_E>能够直接调用.net平台的各种函数库
可以将<BEGIN_E>python<END_E>程序编译成.net程序
ZhPy（周蟒）（支持使用繁/简中文语句编写程序的<BEGIN_E>python<END_E>语言）
<BEGIN_E>Pylons<END_E>-<BEGIN_E>Web应用框架<END_E>
<BEGIN_E>Zope<END_E>-
<BEGIN_E>Plone<END_E>-
<BEGIN_E>Uliweb<END_E>-
Twisted--<BEGIN_E>python<END_E>的网络应用程序框架
<BEGIN_E>python<END_E>
<BEGIN_E>python<END_E>写成的<BEGIN_E>Wiki<END_E>程序
<BEGIN_E>flask<END_E>-
<BEGIN_E>python<END_E>
<BEGIN_E>python<END_E>
<BEGIN_E>python<END_E>
<BEGIN_E>EVE<END_E>-
网络游戏EVE大量使用<BEGIN_E>python<END_E>进行开发
使用<BEGIN_E>python<END_E>编写的BUG管理系统
使用<BEGIN_E>python<END_E>编写的邮件列表软件
以C与<BEGIN_E>python<END_E>开发的开源3D绘图软件
<BEGIN_E>python<END_E>官方文档[11] 
<BEGIN_E>python<END_E>
<BEGIN_E>python<END_E>菜鸟教程[3] 
<BEGIN_E>python<END_E>基础教程[13] 
<BEGIN_E>python<END_E>
<BEGIN_E>C<END_E>语言是一门通用<BEGIN_E>计算机编程语言<END_E>
<BEGIN_E>C语言<END_E>的设计目标是提供一种能以简易的方式<BEGIN_E>编译<END_E>、处理低级<BEGIN_E>存储器<END_E>、产生少量的<BEGIN_E>机器码<END_E>以及不需要任何运行环境支持便能运行的编程语言
尽管<BEGIN_E>C语言<END_E>提供了许多低级处理的功能
以一个标准规格写出的<BEGIN_E>C语言<END_E>程序可在许多电脑平台上进行编译
甚至包含一些嵌入式<BEGIN_E>处理器<END_E>（单片机或称<BEGIN_E>MCU<END_E>）以及超级电脑等作业平台
为了避免各开发厂商用的<BEGIN_E>C语言<END_E>语法产生差异
由美国国家标准局为<BEGIN_E>C语言<END_E>制定了一套完整的美国国家标准语法
作为<BEGIN_E>C语言<END_E>最初的标准
国际标准化组织（ISO）和国际电工委员会（IEC）发布的C11标准是<BEGIN_E>C语言<END_E>的第三个官方标准
也是<BEGIN_E>C语言<END_E>的最新标准
<BEGIN_E>C语言<END_E>之所以命名为C
<BEGIN_E>C语言<END_E>源自<BEGIN_E>Ken Thompson<END_E>发明的<BEGIN_E>B语言<END_E>
<BEGIN_E>剑桥大学<END_E>的Martin
<BEGIN_E>C语言<END_E>宣传图
美国<BEGIN_E>AT&T<END_E>公司<BEGIN_E>贝尔实验室<END_E>（AT&T
找到了台空闲的机器——<BEGIN_E>PDP-7<END_E>
这个操作系统被命名为——<BEGIN_E>UNIX<END_E>
以<BEGIN_E>BCPL<END_E>语言为基础
加入了<BEGIN_E>Thompson<END_E>的开发项目
美国<BEGIN_E>贝尔实验室<END_E>的
这就是<BEGIN_E>C语言<END_E>
<BEGIN_E>C语言<END_E>的主体完成
Thompson和Ritchie迫不及待地开始用它完全重写了<BEGIN_E>UNIX<END_E>
一门心思地投入到了UNIX和<BEGIN_E>C语言<END_E>的开发中
<BEGIN_E>C语言<END_E>自身也在不断地完善
各种版本的UNIX内核和周边工具仍然使用<BEGIN_E>C语言<END_E>作为最主要的开发语言
他们还考虑把<BEGIN_E>UNIX<END_E>移植到其他类型的计算机上使用
<BEGIN_E>C语言<END_E>强大的移植性（Portability）在此显现
为<BEGIN_E>x86<END_E>开发的程序
<BEGIN_E>SPARC<END_E>和<BEGIN_E>ARM<END_E>等机器上运行
而<BEGIN_E>C语言<END_E>程序则可以使用在任意架构的<BEGIN_E>处理器<END_E>上
只要那种架构的处理器具有对应的<BEGIN_E>C语言<END_E><BEGIN_E>编译器<END_E>和库
然后将C源代码<BEGIN_E>编译<END_E>、<BEGIN_E>连接<END_E>成目标<BEGIN_E>二进制文件<END_E>之后即可运行
M.Ritchie<END_E>发表了不依赖于具体机器系统的<BEGIN_E>C语言<END_E>编译文本《可移植的<BEGIN_E>C语言<END_E>编译程序》
<BEGIN_E>C语言<END_E>继续发展
很多有识之士和<BEGIN_E>美国国家标准协会<END_E>为了使这个语言健康地发展下去
建立<BEGIN_E>C语言<END_E>的标准
<BEGIN_E>C语言<END_E>作者和应用程序员组成
<BEGIN_E>ANSI<END_E>发布了第一个完整的<BEGIN_E>C语言<END_E>标准——ANSI
C89在1990年被<BEGIN_E>国际标准组织<END_E>ISO(International
ISO发布了新的<BEGIN_E>C语言<END_E>标准
简称“<BEGIN_E>C99<END_E>”
简称为“<BEGIN_E>C11<END_E>”
<BEGIN_E>GCC<END_E>
<BEGIN_E>MinGW<END_E>
<BEGIN_E>Clang<END_E>
<BEGIN_E>CodeLite<END_E>
<BEGIN_E>C-Free<END_E>
<BEGIN_E>C语言<END_E>没有官方标准
1978年由<BEGIN_E>美国电话电报公司<END_E>(AT&T）贝尔实验室正式发表了<BEGIN_E>C语言<END_E>
<BEGIN_E>C语言<END_E>开发者们称为K&amp;R
<BEGIN_E>C语言<END_E>的非正式的标准说明
<BEGIN_E>C语言<END_E>为K&amp;R
<BEGIN_E>结构体<END_E>（struct）类型
<BEGIN_E>C语言<END_E>被广泛应用
也衍生了<BEGIN_E>C语言<END_E>的很多不同版本
<BEGIN_E>C语言<END_E>标准
美国国家标准协会（ANSI）通过了<BEGIN_E>C语言<END_E>标准
<BEGIN_E>国际标准化组织<END_E>（ISO）和<BEGIN_E>国际电工委员会<END_E>（IEC）把C89标准定为<BEGIN_E>C语言<END_E>的国际标准
国际标准化组织（ISO）和国际电工委员会（IEC）发布了<BEGIN_E>C语言<END_E>的新标准
这是<BEGIN_E>C语言<END_E>的第二个官方标准
复合<BEGIN_E>字面量<END_E>：初始化结构的时候允许对特定的元素赋值
<BEGIN_E>printf<END_E>
<BEGIN_E>scanf<END_E>
<BEGIN_E>GCC<END_E>和其它一些商业编译器支持<BEGIN_E>C99<END_E>的大部分特性
国际标准化组织（ISO）和国际电工委员会（IEC）再次发布了<BEGIN_E>C语言<END_E>的新标准
这是<BEGIN_E>C语言<END_E>的第三个官方标准
也是<BEGIN_E>C语言<END_E>的最新标准
<BEGIN_E>对齐<END_E>处理(Alignment)的标准化(包括_Alignas标志符
alignof<BEGIN_E>运算符<END_E>
aligned_alloc函数以及<BEGIN_E>头文件<END_E>
增强的<BEGIN_E>Unicode<END_E>的支持
包括为<BEGIN_E>UTF-16<END_E>/<BEGIN_E>UTF-32<END_E>编码增加了char16_t和char32_t数据类型
提供了包含<BEGIN_E>unicode<END_E>字符串转换函数的头文件.
<BEGIN_E>gets<END_E>()
这个在<BEGIN_E>gcc<END_E>早已存在
<BEGIN_E>C11<END_E>将其引入标准
<BEGIN_E>fopen<END_E>()
<BEGIN_E>exit<END_E>()失败时可以做最少的清理工作
C++语言代码1、高级语言：它是把<BEGIN_E>高级语言<END_E>的基本结构和<BEGIN_E>语句<END_E>与低级语言的实用性结合起来的工作单元
便于使用、维护以及<BEGIN_E>调试<END_E>
从而使程序完全<BEGIN_E>结构化<END_E>
如Windows、<BEGIN_E>DOS<END_E>、<BEGIN_E>UNIX<END_E>等等；也适用于多种机型
<BEGIN_E>C语言<END_E>对编写需要进行硬件操作的场合
<BEGIN_E>C++<END_E>在这方面做了改进
取消了<BEGIN_E>指针<END_E>操作
但其本身解释在<BEGIN_E>虚拟机<END_E>中运行
<BEGIN_E>C语言<END_E>是一个有结构化程序设计、具有变量作用域（variable
<BEGIN_E>C语言<END_E>传递参数均是以值传递（pass
不同的变量类型可以用<BEGIN_E>结构体<END_E>（struct）组合在一起
<BEGIN_E>C语言<END_E>可以容易的对存储器进行低级控制
<BEGIN_E>预编译<END_E>处理（preprocessor）让<BEGIN_E>C语言<END_E>的编译更具有弹性
<BEGIN_E>C语言<END_E>一共只有32个<BEGIN_E>关键字<END_E>
9种<BEGIN_E>控制语句<END_E>
语言可以像<BEGIN_E>汇编语言<END_E>一样对位、<BEGIN_E>字节<END_E>和地址进行操作
[12] <BEGIN_E>C语言<END_E>的
<BEGIN_E>C语言<END_E>的<BEGIN_E>运算符<END_E>包含的范围很广泛
<BEGIN_E>C语言<END_E>把<BEGIN_E>括号<END_E>、<BEGIN_E>赋值<END_E>、<BEGIN_E>强制类型转换<END_E>等都作为运算符处理
从而使<BEGIN_E>C语言<END_E>的运算类型极其丰富
<BEGIN_E>表达式<END_E>类型多样化
灵活使用各种运算符可以实现在其它<BEGIN_E>高级语言<END_E>中难以实现的运算
<BEGIN_E>C语言<END_E>的数据类型有：<BEGIN_E>整型<END_E>、实型、字符型、数组类型、指针类型、<BEGIN_E>结构体类型<END_E>、共用体类型等
<BEGIN_E>C语言<END_E>提供多种运算符和表达式值的方法
由于<BEGIN_E>C语言<END_E>允许直接访问<BEGIN_E>物理地址<END_E>
能够像<BEGIN_E>汇编语言<END_E>一样对位（bit）、字节和地址进行操作
可用来写<BEGIN_E>系统软件<END_E>
<BEGIN_E>C语言<END_E>描述问题比汇编语言迅速
易于<BEGIN_E>调试<END_E>、修改和移植
<BEGIN_E>C语言<END_E>一般只比汇编程序生成的目标代码效率低10%～20%
<BEGIN_E>C语言<END_E>在不同机器上的C<BEGIN_E>编译程序<END_E>
所以<BEGIN_E>C语言<END_E>的编译程序便于移植
在一个环境上用<BEGIN_E>C语言<END_E>编写的程序
<BEGIN_E>C语言<END_E>有丰富的数据结构和<BEGIN_E>运算符<END_E>
如<BEGIN_E>整型<END_E>、数组类型、指针类型和联合类型等
<BEGIN_E>C语言<END_E>的运算符有34种
<BEGIN_E>C语言<END_E>能直接访问硬件的物理地址
能进行位（<BEGIN_E>bit<END_E>）操作
另外<BEGIN_E>C语言<END_E>具有强大的图形功能
支持多种显示器和<BEGIN_E>驱动器<END_E>
且计算功能、<BEGIN_E>逻辑判断<END_E>功能强大
<BEGIN_E>C语言<END_E>的缺点主要表现在数据的封装性上
<BEGIN_E>C语言<END_E>的语法限制不太严格
对<BEGIN_E>数组下标越界<END_E>不作检查等
<BEGIN_E>C语言<END_E>比其他高级语言较难掌握
对用<BEGIN_E>C语言<END_E>的人
1、<BEGIN_E>对齐<END_E>处理(Alignment）的标准化（包括_Alignas标志符
alignof<BEGIN_E>运算符<END_E>
aligned_alloc函数以及<BEGIN_E>头文件<END_E>）
<BEGIN_E>gcc<END_E>
3、_Generic<BEGIN_E>关键字<END_E>
5、增强的<BEGIN_E>Unicode<END_E>的支持
包括为<BEGIN_E>UTF-16<END_E>/<BEGIN_E>UTF-32<END_E>编码增加了char16_t和char32_t数据类型
9、匿名<BEGIN_E>结构体<END_E>/<BEGIN_E>联合体<END_E>支持
这个在<BEGIN_E>gcc<END_E>早已存在
<BEGIN_E>C11<END_E>将其引入标准
<BEGIN_E>fopen<END_E>（）模式
<BEGIN_E>exit<END_E>（）失败时可以做最少的清理工作
C的数据类型包括：<BEGIN_E>整型<END_E>、字符型、实型或<BEGIN_E>浮点型<END_E>（单精度和双精度）、<BEGIN_E>枚举类型<END_E>、数组类型、<BEGIN_E>结构体类型<END_E>、共用体类型、指针类型和空类型
<BEGIN_E>常量<END_E>其值不可改变
这个声明就是<BEGIN_E>数组<END_E>声明
<BEGIN_E>字符串<END_E>也是一种数组
它们以<BEGIN_E>ASCII<END_E>的<BEGIN_E>NULL<END_E>作为数组的结束
<BEGIN_E>C语言<END_E>中另有
语言区别于其他同时代<BEGIN_E>高级语言<END_E>的主要特征之一
还可以是<BEGIN_E>数组<END_E>、数组元素、函数的地址
通过指针作为<BEGIN_E>形式参数<END_E>可以在函数的调用过程得到一个以上的返回值
<BEGIN_E>C语言<END_E>的字符串其实就是以'\0'字符结尾的char型数组
使用这些函数需要引用<BEGIN_E>头文件<END_E>
在<BEGIN_E>C语言<END_E>中
<BEGIN_E>stdin<END_E>标准输入
<BEGIN_E>stdout<END_E>标准输出
<BEGIN_E>stderr<END_E>输入输出错误[16] 
<BEGIN_E>C语言<END_E>的运算非常灵活
运算种类远多于其它<BEGIN_E>程序设计语言<END_E>
先要明确运算符按<BEGIN_E>优先级<END_E>不同分类
《<BEGIN_E>C程序设计<END_E>》运算符可分为15种优先级
关键字又称为<BEGIN_E>保留字<END_E>
就是已被<BEGIN_E>C语言<END_E>本身使用
例如<BEGIN_E>关键字<END_E>不能用作变量名、函数名等<BEGIN_E>标识符<END_E>
由ISO标准定义的<BEGIN_E>C语言<END_E>关键字共32个：
属于<BEGIN_E>整型数据<END_E>的一种
float：<BEGIN_E>单精度<END_E>浮点型数据
属于<BEGIN_E>浮点数<END_E>据的一种
_Bool:<BEGIN_E>布尔型<END_E>（<BEGIN_E>C99<END_E>标准新增）
_Imaginary:<BEGIN_E>虚数<END_E>
与<BEGIN_E>复数<END_E>基本类型相似
_Generic:提供重载的接口入口（<BEGIN_E>C11<END_E>标准新增）
（<BEGIN_E>C99<END_E>标准新增）
struct：<BEGIN_E>结构体<END_E>声明
union：<BEGIN_E>联合体<END_E>声明
enum：<BEGIN_E>枚举<END_E>声明
（<BEGIN_E>C99<END_E>标准新增）
auto：指定为<BEGIN_E>自动变量<END_E>
static：指定为<BEGIN_E>静态变量<END_E>
register：指定为<BEGIN_E>寄存器<END_E>变量
建议编译器通过寄存器而不是<BEGIN_E>堆栈<END_E>传递参数
extern：指定对应变量为<BEGIN_E>外部变量<END_E>
return：用在<BEGIN_E>函数体<END_E>中
<BEGIN_E>if<END_E>：条件语句
<BEGIN_E>else<END_E>：条件语句否定分支（与if连用）
<BEGIN_E>switch<END_E>：开关语句（多重分支语句）
<BEGIN_E>case<END_E>：开关语句中的分支标记
<BEGIN_E>default<END_E>：开关语句中的“其他”分支
<BEGIN_E>预编译<END_E>宏
<BEGIN_E>条件编译<END_E>
<BEGIN_E>顺序结构<END_E>的程序设计是最简单的
例如分支结构中的<BEGIN_E>复合语句<END_E>、循环结构中的循环体等
<BEGIN_E>顺序结构<END_E>的程序虽然能解决计算、输出等问题
选择结构的程序设计方法的关键在于构造合适的分支条件和<BEGIN_E>分析程序<END_E>流程
选择结构适合于带有<BEGIN_E>逻辑或<END_E>关系比较等条件判断的计算
设计这类程序时往往都要先绘制其<BEGIN_E>程序流程图<END_E>
程序流程图是根据解题分析所绘制的程序执行<BEGIN_E>流程图<END_E>
<BEGIN_E>循环结构<END_E>可以减少源程序重复书写的工作量
<BEGIN_E>C语言<END_E>中提供四种循环
while循环和<BEGIN_E>for循环<END_E>
否则就可能成了一个<BEGIN_E>死循环<END_E>
而<BEGIN_E>goto语句<END_E>与<BEGIN_E>if<END_E>构成的循环
for循环结构是<BEGIN_E>C语言<END_E>中最具有特色的循环语句
for循环语句是<BEGIN_E>C语言<END_E>种功能最为强大的语句
甚至在一定程度上可以代替其他的循环<BEGIN_E>语句<END_E>
<BEGIN_E>C语言<END_E>的模块化程序结构用函数来实现
然后通过主<BEGIN_E>函数调用<END_E>函数及函数调用函数来实现一大型问题的C程序编写
1、一个<BEGIN_E>C语言<END_E><BEGIN_E>源程序<END_E>可以由一个或多个<BEGIN_E>源文件<END_E>组成
都有一个且只能有一个<BEGIN_E>main函数<END_E>
即<BEGIN_E>主函数<END_E>
4、源程序中可以有<BEGIN_E>预处理命令<END_E>（包括include
<BEGIN_E>函数头<END_E>和花括号“}”之后不能加分号
6、<BEGIN_E>标识符<END_E>
我们可以把函数看成一个“<BEGIN_E>黑盒子<END_E>”
使之容易读、写、理解、排除错误、<BEGIN_E>修改<END_E>和维护
整个程序从这个<BEGIN_E>主函数<END_E>开始执行
<BEGIN_E>C语言<END_E>发展的那么多年来
用<BEGIN_E>C语言<END_E>开发的系统和程序浩如烟海
C提供了标准<BEGIN_E>C语言<END_E>库函数
<BEGIN_E>C语言<END_E>初学者比较喜欢的<BEGIN_E>Turbo
运算符的优先级从高到低大致是：<BEGIN_E>单目运算符<END_E>、<BEGIN_E>算术运算符<END_E>、<BEGIN_E>关系运算符<END_E>、<BEGIN_E>逻辑运算符<END_E>、条件运算符、赋值运算符（=）和逗号运算符
<BEGIN_E>C语言<END_E>标准语法是int
并不是说<BEGIN_E>C语言<END_E>中还未定义这种行为
<BEGIN_E>运算符<END_E>用于执行程序代码运算
会针对一个以上<BEGIN_E>操作数<END_E>项目来进行运算
而<BEGIN_E>运算符<END_E>则是“+”
在vb2005中<BEGIN_E>运算符<END_E>大致可以分为5种类型：<BEGIN_E>算术运算符<END_E>、连接<BEGIN_E>运算符<END_E>、<BEGIN_E>关系运算符<END_E>、<BEGIN_E>赋值运算符<END_E>和<BEGIN_E>逻辑运算符<END_E>
C语言是一种<BEGIN_E>计算机程序设计语言<END_E>
它既具有<BEGIN_E>高级语言<END_E>的特点
又具有<BEGIN_E>汇编语言<END_E>的特点
具体应用比如单片机以及<BEGIN_E>嵌入式系统开发<END_E>
C语言把除了控制<BEGIN_E>语句<END_E>和输入输出以外的几乎所有的基本操作都作为<BEGIN_E>运算符<END_E>处理
可见其范围的宽(如：将赋值符“=”作为<BEGIN_E>赋值运算符<END_E>、方括号作为<BEGIN_E>下标<END_E><BEGIN_E>运算符<END_E>）
C的<BEGIN_E>运算符<END_E>有以下几类：
1.<BEGIN_E>算术运算符<END_E>：*
2.关系<BEGIN_E>运算符<END_E>：
3.<BEGIN_E>逻辑运算符<END_E>：!
4.位<BEGIN_E>运算符<END_E>：>
5.<BEGIN_E>赋值运算符<END_E>：=及扩展赋值<BEGIN_E>运算符<END_E>
6.条件<BEGIN_E>运算符<END_E>：?:
7.逗号<BEGIN_E>运算符<END_E>：
8.<BEGIN_E>指针运算符<END_E>：*和&
9.求字节数<BEGIN_E>运算符<END_E>：sizeof
10.<BEGIN_E>强制类型转换<END_E><BEGIN_E>运算符<END_E>：(类型)
11.分量<BEGIN_E>运算符<END_E>：.
12.<BEGIN_E>下标<END_E><BEGIN_E>运算符<END_E>：[
13.其他：如<BEGIN_E>函数调用<END_E><BEGIN_E>运算符<END_E>:()
注意：条件<BEGIN_E>运算符<END_E>是C语言中惟一一个三目(三元)<BEGIN_E>运算符<END_E>
圆括号【（）】、<BEGIN_E>下标<END_E><BEGIN_E>运算符<END_E>【[]】、分量<BEGIN_E>运算符<END_E>的指向<BEGIN_E>结构体<END_E>成员<BEGIN_E>运算符<END_E>【->】、结构体成员<BEGIN_E>运算符<END_E>【.】
<BEGIN_E>逻辑非<END_E><BEGIN_E>运算符<END_E>【!】、按位取反<BEGIN_E>运算符<END_E>【~】、自增自减<BEGIN_E>运算符<END_E>【++
--】、负号<BEGIN_E>运算符<END_E>【-】、<BEGIN_E>类型转换<END_E><BEGIN_E>运算符<END_E>【(类型)】、<BEGIN_E>指针运算符<END_E>和取地址<BEGIN_E>运算符<END_E>【*和&】、长度<BEGIN_E>运算符<END_E>【sizeof】
第三级：乘法<BEGIN_E>运算符<END_E>【*】、除法<BEGIN_E>运算符<END_E>【/】、取余<BEGIN_E>运算符<END_E>【%】
第四级：加法<BEGIN_E>运算符<END_E>【+】、减法<BEGIN_E>运算符<END_E>【-】
第五级：左移动<BEGIN_E>运算符<END_E>【>】
第六级：关系<BEGIN_E>运算符<END_E>【
第七级：等于<BEGIN_E>运算符<END_E>【==】、不等于<BEGIN_E>运算符<END_E>【!=】
第八级：按位与<BEGIN_E>运算符<END_E>【&】
第九级：按位异或<BEGIN_E>运算符<END_E>【^】
第十级：按位或<BEGIN_E>运算符<END_E>【|】
第十一级：<BEGIN_E>逻辑与<END_E><BEGIN_E>运算符<END_E>【&&】
第十二级：<BEGIN_E>逻辑或<END_E><BEGIN_E>运算符<END_E>【||】
第十三级：条件<BEGIN_E>运算符<END_E>【?:】
第十四级：<BEGIN_E>赋值运算符<END_E>【=
第十五级：逗号<BEGIN_E>运算符<END_E>【
G2是<BEGIN_E>单目运算符<END_E>
G13条件<BEGIN_E>运算符<END_E>是<BEGIN_E>三目运算符<END_E>
其他都是<BEGIN_E>双目运算符<END_E>
②G2、G13条件<BEGIN_E>运算符<END_E>、G14赋值<BEGIN_E>运算符<END_E>是自右向左的【也就是右结合性】
归纳各类<BEGIN_E>运算符<END_E>【高到低】：
初等<BEGIN_E>运算符<END_E>【（）、->、.】
单目<BEGIN_E>运算符<END_E>G2
<BEGIN_E>算术运算符<END_E>(先乘除【取余】
位<BEGIN_E>运算符<END_E>【>】
<BEGIN_E>关系运算符<END_E>G6
位<BEGIN_E>运算符<END_E>【递减&
<BEGIN_E>逻辑运算符<END_E>(不包括！)
条件<BEGIN_E>运算符<END_E>
<BEGIN_E>赋值运算符<END_E>G14
逗号<BEGIN_E>运算符<END_E>
C语言中各<BEGIN_E>运算符<END_E>的结合性分为两种：左结合性和右结合性
例如：算术<BEGIN_E>运算符<END_E>的结合性是自左至右
最典型的右结合性<BEGIN_E>运算符<END_E>是赋值<BEGIN_E>运算符<END_E>
C语言<BEGIN_E>运算符<END_E>中有不少为右结合性
Word中可以添加一般应用条件下的所有<BEGIN_E>运算符<END_E>
单击需要添加<BEGIN_E>运算符<END_E>的公式使其处于<BEGIN_E>编辑状态<END_E>
并将插入条<BEGIN_E>光标<END_E>定位到目标位置
在打开的下拉菜单中选择“<BEGIN_E>运算符<END_E>”选项
并在打开的<BEGIN_E>运算符<END_E>面板中选择所需的<BEGIN_E>运算符<END_E>
中的<BEGIN_E>运算符<END_E>分为：四则<BEGIN_E>运算符<END_E>、逻辑<BEGIN_E>运算符<END_E>、三目<BEGIN_E>运算符<END_E>和位<BEGIN_E>运算符<END_E>
<BEGIN_E>运算符<END_E>优先级
<BEGIN_E>运算符<END_E>优先级指定了两个表达式绑定得有多“紧密”
如果<BEGIN_E>运算符<END_E>优先级相同
下表从高到低列出了<BEGIN_E>运算符<END_E>的优先级
同一行中的<BEGIN_E>运算符<END_E>具有相同优先级
<BEGIN_E>运算符<END_E>优先级
<BEGIN_E>运算符<END_E>
递增/递减<BEGIN_E>运算符<END_E>
算数<BEGIN_E>运算符<END_E>
算数<BEGIN_E>运算符<END_E>和字符串<BEGIN_E>运算符<END_E>
位<BEGIN_E>运算符<END_E>
比较<BEGIN_E>运算符<END_E>
比较<BEGIN_E>运算符<END_E>
位<BEGIN_E>运算符<END_E>和引用
位<BEGIN_E>运算符<END_E>
位<BEGIN_E>运算符<END_E>
逻辑<BEGIN_E>运算符<END_E>
逻辑<BEGIN_E>运算符<END_E>
三元<BEGIN_E>运算符<END_E>
赋值<BEGIN_E>运算符<END_E>
逻辑<BEGIN_E>运算符<END_E>
逻辑<BEGIN_E>运算符<END_E>
逻辑<BEGIN_E>运算符<END_E>
<BEGIN_E>运算符<END_E>
变量<BEGIN_E>赋值<END_E>
算术<BEGIN_E>运算符<END_E>
算术<BEGIN_E>运算符<END_E>用于执行变量与/或值之间的算术运算
下面的表格解释了这些<BEGIN_E>算术运算符<END_E>：
<BEGIN_E>运算符<END_E>
赋值<BEGIN_E>运算符<END_E>用于给
下面的表格解释了赋值<BEGIN_E>运算符<END_E>：
<BEGIN_E>运算符<END_E>
<BEGIN_E>运算符<END_E>用于把文本值或字符串变量加起来（连接起来）
<BEGIN_E>运算符<END_E>
的关系型<BEGIN_E>数据库管理系统<END_E>中编程语言
主要有六大类：算术<BEGIN_E>运算符<END_E>、赋值<BEGIN_E>运算符<END_E>、位<BEGIN_E>运算符<END_E>、比较<BEGIN_E>运算符<END_E>、逻辑<BEGIN_E>运算符<END_E>和字符串联<BEGIN_E>运算符<END_E>
1）算术<BEGIN_E>运算符<END_E>包括（+）、减（-）、乘（*）、除（/）和取模（%）
2）赋值<BEGIN_E>运算符<END_E>“=”
3）位<BEGIN_E>运算符<END_E>
比较<BEGIN_E>运算符<END_E>
5）逻辑<BEGIN_E>运算符<END_E>
6）字符串联<BEGIN_E>运算符<END_E>
<BEGIN_E>PyGTK<END_E>让你用Python轻松创建具有<BEGIN_E>图形用户界面<END_E>的程序.底层的GTK+提供了各式的可视元素和功能
<BEGIN_E>PyGTK<END_E>让你用Python轻松创建具有<BEGIN_E>图形用户界面<END_E>的程序.底层的GTK+提供了各式的可视元素和功能
<BEGIN_E>PyGTK<END_E>真正具有跨平台性
<BEGIN_E>PyGTK<END_E>还有一流的处理本地化语言的独特功能.
<BEGIN_E>PyGTK<END_E>是<BEGIN_E>自由软件<END_E>
一定不陌生)和GIMP图象<BEGIN_E>编辑器<END_E>的开发工具箱．它是世界上许多程序员的选择
<BEGIN_E>工程<END_E>是科学和数学的某种应用
使自然界的<BEGIN_E>物质<END_E>和<BEGIN_E>能源<END_E>的特性能够通过各种<BEGIN_E>结构<END_E>、<BEGIN_E>机器<END_E>、<BEGIN_E>产品<END_E>、<BEGIN_E>系统<END_E>和<BEGIN_E>过程<END_E>
欧洲创造了“<BEGIN_E>工程<END_E>”一词
随着<BEGIN_E>人类文明<END_E>的发展
而是各种各样的所谓“<BEGIN_E>人造系统<END_E>”（比如建筑物、轮船、铁路<BEGIN_E>工程<END_E>、海上<BEGIN_E>工程<END_E>、飞机等等）
于是<BEGIN_E>工程<END_E>的概念就产生了
“<BEGIN_E>工程<END_E>”一词有广义和狭义之分
<BEGIN_E>工程<END_E>定义为“以某组设想的<BEGIN_E>目标<END_E>为依据
通过有组织的一群人将某个（或某些）现有实体（自然的或人造的）转化为具有预期使用价值的<BEGIN_E>人造<END_E><BEGIN_E>产品<END_E>过程”
<BEGIN_E>工程<END_E>则定义为由一群(个)人为达到某种目的
<BEGIN_E>工程<END_E>严促
《应诏陈言<BEGIN_E>工程<END_E>奏》：“今纵以为紧急<BEGIN_E>工程<END_E>不可终废
<BEGIN_E>工程<END_E>浩繁
如：土木<BEGIN_E>工程<END_E>、机械<BEGIN_E>工程<END_E>、水利<BEGIN_E>工程<END_E>等
详见<BEGIN_E>工程<END_E>
﹞所著有《读书<BEGIN_E>工程<END_E>》
《来生债》第一折：“只怕睡着了误了<BEGIN_E>工程<END_E>
担误<BEGIN_E>工程<END_E>
<BEGIN_E>工程<END_E>的主要依据是数学、物理学、化学
依照<BEGIN_E>工程<END_E>对科学的关系
<BEGIN_E>工程<END_E>的所有各分支领域都有如下主要职能：
如：水利<BEGIN_E>工程<END_E>、化学<BEGIN_E>工程<END_E>、土木建筑<BEGIN_E>工程<END_E>、<BEGIN_E>遗传工程<END_E>、系统<BEGIN_E>工程<END_E>、生物<BEGIN_E>工程<END_E>、海洋<BEGIN_E>工程<END_E>、<BEGIN_E>环境微生物工程<END_E>
如：城市改建<BEGIN_E>工程<END_E>、<BEGIN_E>京九铁路<END_E><BEGIN_E>工程<END_E>、菜蓝子<BEGIN_E>工程<END_E>
3、关于<BEGIN_E>工程<END_E>的研究——称为“<BEGIN_E>工程学<END_E>”
4、关于<BEGIN_E>工程<END_E>的立项——称为“<BEGIN_E>工程<END_E>项目”
5、一个全面的、大型的、复杂的包含各子项目的<BEGIN_E>工程<END_E>——称为“系统<BEGIN_E>工程<END_E>”[1] 
<BEGIN_E>简洁<END_E>
是<BEGIN_E>形容词<END_E>
<BEGIN_E>颜延之<END_E>
《<BEGIN_E>陶徵士诔<END_E>》：“<BEGIN_E>廉深<END_E>简絜
贞夷<BEGIN_E>粹温<END_E>
他的文章<BEGIN_E>简洁<END_E>易懂
语言<BEGIN_E>简洁<END_E>、生动
画面<BEGIN_E>简洁<END_E>明快
电景音乐具有<BEGIN_E>简洁<END_E>、概括的特点
<BEGIN_E>现代汉语语法<END_E>的结构<BEGIN_E>简洁<END_E>明了
他的回答非常的<BEGIN_E>简洁<END_E>而明了[1] 
《<BEGIN_E>南史<END_E>·王思远传》：“
立身<BEGIN_E>简洁<END_E>
<BEGIN_E>觇知<END_E>衣服垢秽
方便不前；<BEGIN_E>形仪<END_E>新楚
<BEGIN_E>颜延之<END_E>
《<BEGIN_E>陶徵士诔<END_E>》：“<BEGIN_E>廉深<END_E>简絜
贞夷<BEGIN_E>粹温<END_E>
<BEGIN_E>元辅<END_E>
<BEGIN_E>简洁<END_E>贞方
<BEGIN_E>苏辙<END_E>
其书<BEGIN_E>简洁<END_E>而明肃
《隐居通议·诗歌三》：“此独<BEGIN_E>简洁<END_E>峻峭
《晚晴集·永远活在我们心中的周总理》：“他的<BEGIN_E>简洁<END_E>的讲话
<BEGIN_E>PDP-7<END_E>
<BEGIN_E>肯·汤普逊<END_E>利用一台<BEGIN_E>PDP-7<END_E>机器
写出了第一版的<BEGIN_E>UNIX<END_E>操作系统
<BEGIN_E>C语言<END_E>之父
<BEGIN_E>UNIX<END_E>之父
曾担任<BEGIN_E>朗讯科技公司<END_E><BEGIN_E>贝尔实验室<END_E>下属的计算机科学研究中心系统软件研究部的主任一职
Kernighan）一起出版了名著《<BEGIN_E>C程序设计语言<END_E>（The
对C语言和其他编程语言、<BEGIN_E>Multics<END_E>和<BEGIN_E>Unix<END_E>等操作系统的发展做出了巨大贡献
里奇在<BEGIN_E>哈佛大学<END_E>学习物理学和应用数学毕业
1983年他与肯·汤普逊一起获得了<BEGIN_E>图灵奖<END_E>
并且在这期间Ken做了第一个计算机<BEGIN_E>象棋大师<END_E>
丹尼斯·里奇(3张)丹尼斯·里奇获得学士学位并且获得<BEGIN_E>哈佛大学<END_E>更高的学位
1968年获得<BEGIN_E>数学博士<END_E>
加入了<BEGIN_E>Multics<END_E>项目
里奇负责多道处理机的BCPL语言和GE650的<BEGIN_E>编译器<END_E>
Language》(即《<BEGIN_E>C程序设计语言<END_E>》)
那么<BEGIN_E>Unix<END_E>将<BEGIN_E>胎死腹中<END_E>
它对许多现代的编程语言如C++、C#、<BEGIN_E>Objective-C<END_E>、Java和<BEGIN_E>JavaScript<END_E>拥有极大的影响
在操作系统方面Unix也具有极大的影响：今天市场上有许多不同的Unix版本如<BEGIN_E>AIX<END_E>、<BEGIN_E>Solaris<END_E>、Mac
X和<BEGIN_E>BSD<END_E>等
以及与Unix非常相似的系统如<BEGIN_E>Minix<END_E>和非常普及的<BEGIN_E>Linux操作系统<END_E>
里奇还参加发展了<BEGIN_E>Unix<END_E>和C语言的两个后继软件：Plan
奖（1982）；贝尔实验室特别人员奖（1983）；美国计算机协会（ACM）的<BEGIN_E>图灵奖<END_E>（1983）；
<BEGIN_E>Unix<END_E>
<BEGIN_E>C++<END_E>的名字也是源自C语言的利器
<BEGIN_E>ARM<END_E>处理器是英国Acorn有限公司设计的低功耗成本的第一款<BEGIN_E>RISC<END_E>微处理器
<BEGIN_E>ARM<END_E>处理器本身是32位设计
<BEGIN_E>ARM<END_E>的Jazelle技术使Java加速得到比基于软件的Ja<BEGIN_E>ARM<END_E>处理器阶梯图va<BEGIN_E>虚拟机<END_E>(JVM)高得多的性能
CPU功能上增加DSP<BEGIN_E>指令集<END_E>提供增强的16位和32位算术运算能力
<BEGIN_E>ARM<END_E>还提供两个前沿特性来辅助带深嵌入处理器的高集成SoC器件的调试
<BEGIN_E>ARM<END_E>处理器的三大特点是：耗电少功能强、16位/32位双<BEGIN_E>指令集<END_E>和合作伙伴众多
2、支持Thumb（16位）/<BEGIN_E>ARM<END_E>（32位）双指令集
3、大量使用<BEGIN_E>寄存器<END_E>
6、<BEGIN_E>指令长度<END_E>固定
<BEGIN_E>体系结构<END_E>
复杂<BEGIN_E>指令集计算机<END_E>）
在CISC<BEGIN_E>指令集<END_E>的各种指令中
<BEGIN_E>精简指令集计算机<END_E>）
避免复杂指令；将<BEGIN_E>指令长度<END_E>固定
<BEGIN_E>指令格式<END_E>和寻址方式种类减少；以控制逻辑为主
3　大量使用<BEGIN_E>寄存器<END_E>
只有加载/存储指令可以访问<BEGIN_E>存储器<END_E>
<BEGIN_E>ARM<END_E><BEGIN_E>体系结构<END_E>还采用了一些特别的技术
以提高数据的<BEGIN_E>传输效率<END_E>
<BEGIN_E>ARM<END_E>处理器共有37个寄存器
1　31个<BEGIN_E>通用寄存器<END_E>
包括<BEGIN_E>程序计数器<END_E>（PC指针）
2　6个<BEGIN_E>状态寄存器<END_E>
<BEGIN_E>ARM<END_E>微处理器的在较新的<BEGIN_E>体系结构<END_E>中支持两种<BEGIN_E>指令集<END_E>：<BEGIN_E>ARM<END_E>指令集和Thumb指令集
<BEGIN_E>ARM<END_E>指令为32位的长度
Thumb指令集为<BEGIN_E>ARM<END_E>指令集的功能子集
但与等价的<BEGIN_E>ARM<END_E>代码相比较
当前<BEGIN_E>ARM<END_E>体系结构的扩充包括：
16位<BEGIN_E>指令集<END_E>
允许直接执行Java<BEGIN_E>字节码<END_E>
<BEGIN_E>ARM<END_E>处理器系列提供的解决方案有：
·无线、消费类电子和图像应用的<BEGIN_E>开放平台<END_E>；
·存储、自动化、工业和网络应用的<BEGIN_E>嵌入式实时系统<END_E>；
·<BEGIN_E>智能卡<END_E>和<BEGIN_E>SIM卡<END_E>的安全应用
<BEGIN_E>ARM<END_E>处理器正常的程序<BEGIN_E>执行状态<END_E>
用于<BEGIN_E>虚拟存储器<END_E>及存储器保护
用于通用的<BEGIN_E>中断处理<END_E>
支持硬件<BEGIN_E>协处理器<END_E>的软件仿真
<BEGIN_E>ARM<END_E>处理器的运行模式可以通过软件改变
也可以通过<BEGIN_E>外部中断<END_E>或<BEGIN_E>异常处理<END_E>改变
Acorn公司打算使用<BEGIN_E>摩托罗拉<END_E>公司的16位芯片
Furber用它做出了一台RISC<BEGIN_E>指令集<END_E>的计算机
简称<BEGIN_E>ARM<END_E>（Acorn
这就是<BEGIN_E>ARM<END_E>这个名字的由来
<BEGIN_E>RISC<END_E>的全称是"精简指令集计算机"（reduced
早期使用<BEGIN_E>ARM<END_E>芯片的典型设备
<BEGIN_E>ARM<END_E>很快开发成Acorn的台式机产品
Acorn公司正式改组为<BEGIN_E>ARM<END_E>计算机公司
<BEGIN_E>ARM<END_E>
占据了低功耗、低成本和高性能的<BEGIN_E>嵌入式系统<END_E>应用领域的领先地位
<BEGIN_E>ARM<END_E>公司既不生产芯片也不销售芯片
下一版Windows将正式支持<BEGIN_E>ARM<END_E>处理器
这是计算机工业<BEGIN_E>ARM<END_E>处理器发展历史上的一件大事
<BEGIN_E>ARM<END_E>处理器的市场份额超过90%；在<BEGIN_E>服务器<END_E>市场
<BEGIN_E>ARM<END_E>成为主流
Intel公司将被击败！<BEGIN_E>ARM<END_E>微处理器核技术广泛应用于便携式通信产品、手持运算、多媒体和嵌入式解决方案等领域
它的主角<BEGIN_E>ARM<END_E>公司却没有受到太多的关注
它与<BEGIN_E>ARM<END_E>竞争也将非常吃力
因为<BEGIN_E>ARM<END_E>的商业模式是开放的
<BEGIN_E>ARM<END_E>
<BEGIN_E>ARM<END_E>架构的处理器
AMD、<BEGIN_E>ARM<END_E>在服务器领域的合作已经得到了戴尔、惠普两大服务器厂商
AMD的首批<BEGIN_E>ARM<END_E>处理器于2014年问世
<BEGIN_E>ARM<END_E>7系列　<BEGIN_E>ARM<END_E>9系列　<BEGIN_E>ARM<END_E>9E系列　<BEGIN_E>ARM<END_E>10E系列
SecurCore系列　Intel的Strong<BEGIN_E>ARM<END_E>
<BEGIN_E>ARM<END_E>11系列
<BEGIN_E>ARM<END_E>7、<BEGIN_E>ARM<END_E>9、<BEGIN_E>ARM<END_E>9E和<BEGIN_E>ARM<END_E>10为4个通用处理器系列
4500通信处理器基于采用28纳米工艺的<BEGIN_E>ARM<END_E>
并搭载<BEGIN_E>ARM<END_E>全新CoreLink
<BEGIN_E>ARM<END_E>公司在经典处理器<BEGIN_E>ARM<END_E>11以后的产品改用<BEGIN_E>Cortex<END_E>命名
<BEGIN_E>ARM<END_E>内核
(I/D)/<BEGIN_E>MMU<END_E>
<BEGIN_E>MIPS<END_E>于
<BEGIN_E>ARM<END_E>1
<BEGIN_E>ARM<END_E>v1
<BEGIN_E>ARM<END_E>1
<BEGIN_E>ARM<END_E>2
<BEGIN_E>ARM<END_E>v2
<BEGIN_E>ARM<END_E>2
<BEGIN_E>ARM<END_E>v2a
<BEGIN_E>ARM<END_E>250
<BEGIN_E>ARM<END_E>3
<BEGIN_E>ARM<END_E>v2a
<BEGIN_E>ARM<END_E>2a
首次在<BEGIN_E>ARM<END_E>架构上使用处理器高速缓存
<BEGIN_E>ARM<END_E>6
<BEGIN_E>ARM<END_E>v3
<BEGIN_E>ARM<END_E>610
<BEGIN_E>ARM<END_E>7TDMI
<BEGIN_E>ARM<END_E>v4T
<BEGIN_E>ARM<END_E>7TDMI(-S)
<BEGIN_E>iPod<END_E>
<BEGIN_E>ARM<END_E>710T
<BEGIN_E>ARM<END_E>720T
<BEGIN_E>ARM<END_E>740T
<BEGIN_E>ARM<END_E>v5TEJ
<BEGIN_E>ARM<END_E>7EJ-S
<BEGIN_E>ARM<END_E>9TDMI
<BEGIN_E>ARM<END_E>v4T
<BEGIN_E>ARM<END_E>9TDMI
<BEGIN_E>ARM<END_E>920T
<BEGIN_E>ARMadillo<END_E>
<BEGIN_E>GP32<END_E>
<BEGIN_E>GP2X<END_E>（第一颗内核）
Zodiac（<BEGIN_E>Motorola<END_E>i.
<BEGIN_E>ARM<END_E>922T
<BEGIN_E>ARM<END_E>940T
<BEGIN_E>GP2X<END_E>（第二颗内核）
<BEGIN_E>ARM<END_E>9E
<BEGIN_E>ARM<END_E>v5TE
<BEGIN_E>ARM<END_E>946E-S
<BEGIN_E>Nokia<END_E><BEGIN_E>N-Gage<END_E>Conexant
<BEGIN_E>ARM<END_E>966E-S
<BEGIN_E>ARM<END_E>968E-S
<BEGIN_E>ARM<END_E>v5TEJ
<BEGIN_E>ARM<END_E>926EJ-S
<BEGIN_E>Benq<END_E>（x65
<BEGIN_E>ARM<END_E>v5TE
<BEGIN_E>ARM<END_E>996HS
<BEGIN_E>ARM<END_E>10E
<BEGIN_E>ARM<END_E>v5TE
<BEGIN_E>ARM<END_E>1020E
<BEGIN_E>ARM<END_E>1022E
<BEGIN_E>ARM<END_E>v5TE
<BEGIN_E>ARM<END_E>1026EJ-S
<BEGIN_E>XScale<END_E>
<BEGIN_E>ARM<END_E>v5TE
<BEGIN_E>BogoMips<END_E>600
<BEGIN_E>BogoMips<END_E>@400
<BEGIN_E>Gumstix<END_E>
<BEGIN_E>HTC<END_E>Universal
<BEGIN_E>ARM<END_E>11
<BEGIN_E>ARM<END_E>v6
<BEGIN_E>ARM<END_E>1136J(F)-S
<BEGIN_E>Zune<END_E>
<BEGIN_E>ARM<END_E>v6T2
<BEGIN_E>ARM<END_E>1156T2(F)-S
<BEGIN_E>ARM<END_E>v6KZ
<BEGIN_E>ARM<END_E>1176JZ(F)-S
<BEGIN_E>ARM<END_E>v6K
<BEGIN_E>ARM<END_E>11
<BEGIN_E>ARM<END_E>v7-A
<BEGIN_E>ARM<END_E>v7-R
<BEGIN_E>Broadcom<END_E>is
<BEGIN_E>ARM<END_E>v7-M
新款<BEGIN_E>ARM<END_E>v8架构<BEGIN_E>ARM<END_E>Cortex-A50处理器系列产品
进一步扩大<BEGIN_E>ARM<END_E>在高性能与低功耗领域的领先地位
该处理器系列的可扩展性使<BEGIN_E>ARM<END_E>的合作伙伴能够针对智能手机、高性能服务器等各类不同市场需求开发系统级芯片（SoC）[5] 
<BEGIN_E>ARM<END_E>Cortex-A50处理器系列:
为验证软件提高10倍的运行速度与<BEGIN_E>ARM<END_E>Mali图形处理器系列互用
与CCI-400、CCN-504等<BEGIN_E>ARM<END_E>CoreLink缓存一致性结构组件达成多核心缓存一致性
<BEGIN_E>ARM<END_E>Cortex-A57处理器:
最先进、单线程性能最高的<BEGIN_E>ARM<END_E>应用处理器能提升
<BEGIN_E>ARM<END_E>Cortex-A53处理器:
史上效率最高的<BEGIN_E>ARM<END_E>应用处理器
可扩展数据平面（dataplane）应用可将每毫瓦及每平方毫米性能发挥到极致针对个别线程计算应用程序进行了传输处理优化Cortex-A53处理器结合Cortex-A57及<BEGIN_E>ARM<END_E>的big.LITTLE处理技术
整体电路化却又不采用<BEGIN_E>微码<END_E>
就像早期使用在<BEGIN_E>Acorn<END_E>微电脑的8位6502处理器
<BEGIN_E>ARM<END_E>架构包含了下述<BEGIN_E>RISC<END_E>特性：
架构不支援地址不对齐内存存取（<BEGIN_E>ARM<END_E>v6内核现已支援）正交<BEGIN_E>指令集<END_E>（任意存取指令可以任意的<BEGIN_E>寻址方式<END_E>存取数据Orthogonal
<BEGIN_E>操作码<END_E>（opcode）长度
弥补<BEGIN_E>分支预测<END_E>器（branch
shifter）可用来执行大部分的算数指令和寻址计算而不会损失效能强大的索引<BEGIN_E>寻址模式<END_E>（addressing
具有可切换的<BEGIN_E>暂存器<END_E>组有个附加在<BEGIN_E>ARM<END_E>设计中好玩的东西
有个标准的范例引用<BEGIN_E>欧几里德<END_E>的<BEGIN_E>最大公因子<END_E>算法：
在<BEGIN_E>ARM<END_E>
<BEGIN_E>汇编语言<END_E>中
另一项<BEGIN_E>指令集<END_E>的特色是
能将位移（shift）和回转（rotate）等功能并成"资料处理"型的指令（算数、逻辑、和<BEGIN_E>暂存器<END_E>之间的搬移）
2);在<BEGIN_E>ARM<END_E>之下
#2这结果可让一般的<BEGIN_E>ARM<END_E>程式变得更加紧密
即使在<BEGIN_E>ARM<END_E>以一般认定为慢速的速度下执行
<BEGIN_E>ARM<END_E>处理器还有一些在其他RISC的架构所不常见到的特色
例如PC-相对寻址（的确在<BEGIN_E>ARM<END_E>上PC为16个<BEGIN_E>暂存器<END_E>的其中一个）以及
<BEGIN_E>ARM<END_E>
不断地增加它的<BEGIN_E>指令集<END_E>
<BEGIN_E>ARM<END_E>
处理器（比<BEGIN_E>ARM<END_E>7TDMI更早）
<BEGIN_E>ARM<END_E>7
<BEGIN_E>ARM<END_E>9
包含一颗较快的<BEGIN_E>加法器<END_E>
这个架构使用“<BEGIN_E>协处理器<END_E>”提供一种非侵入式的方法来延伸指令集
<BEGIN_E>ARM<END_E>
通常透过将装置的实体<BEGIN_E>暂存器<END_E>对应到
<BEGIN_E>ARM<END_E>
<BEGIN_E>XScale<END_E>
较新的<BEGIN_E>ARM<END_E>处理器有一种16-bit指令模式
opcode能更有效地使用有限的<BEGIN_E>内存带宽<END_E>
并自行最佳化一些使用（非Thumb）32位<BEGIN_E>指令集<END_E>的CPU相关程式区
<BEGIN_E>ARM<END_E>7TDMI
<BEGIN_E>ARM<END_E>9
<BEGIN_E>XScale<END_E>
<BEGIN_E>ARM<END_E>
它能在现存的<BEGIN_E>ARM<END_E>与Thumb模式之间互相执行
首颗具备Jazelle技术的处理器是<BEGIN_E>ARM<END_E>926EJ-S：Jazelle以一个英文字母'J'标示于CPU名称中
<BEGIN_E>ARM<END_E>1156
<BEGIN_E>指令集<END_E>
<BEGIN_E>ARM<END_E>
<BEGIN_E>ARM<END_E>
<BEGIN_E>Cortex-A8<END_E>
使得<BEGIN_E>指令集<END_E>能特别适用于执行阶段（Runtime）的编码产生（例如即时编译）
<BEGIN_E>Limbo<END_E>、Java、<BEGIN_E>C#<END_E>、<BEGIN_E>Perl<END_E>
<BEGIN_E>Python<END_E>
<BEGIN_E>即时编译器<END_E>
<BEGIN_E>SIMD<END_E>（Single
单指令多重数据）<BEGIN_E>指令集<END_E>
<BEGIN_E>GSM<END_E>
NEON具有一组广泛的指令集、各自的<BEGIN_E>寄存器<END_E>阵列
并以<BEGIN_E>SIMD<END_E>
是在协同处理器针对<BEGIN_E>ARM<END_E>架构的衍生技术
它提供低成本的单精度和倍精度<BEGIN_E>浮点运算<END_E>能力
<BEGIN_E>SIMD<END_E>（单指令多重数据）平行化的短向量指令执行
在<BEGIN_E>ARM<END_E>-based处理器中
的功能但在<BEGIN_E>opcode<END_E>层面上来说并不具有相容性
<BEGIN_E>ARM<END_E>v6KZ
针对<BEGIN_E>系统单芯片<END_E>（<BEGIN_E>SoC<END_E>）内加入专属的安全核心
这种<BEGIN_E>内核<END_E>领域之间的切换通常是与处理器其他功能完全无关联性（orthogonal）
1、<BEGIN_E>ARM<END_E>微处理器内核的选择从前面所介绍的内容可知
<BEGIN_E>ARM<END_E>微处理器包含一系列的内核结构
就需要选择<BEGIN_E>ARM<END_E>720T以上带有MMU（Memory
Unit）功能的<BEGIN_E>ARM<END_E>芯片
<BEGIN_E>ARM<END_E>720T、<BEGIN_E>ARM<END_E>920T、<BEGIN_E>ARM<END_E>922T、<BEGIN_E>ARM<END_E>946T、Strong-<BEGIN_E>ARM<END_E>都带有MMU功能
<BEGIN_E>ARM<END_E>7TDMI则没有MMU
但目前有uCLinux等不需要MMU支持的操作系统可运行于<BEGIN_E>ARM<END_E>7TDMI硬件平台之上
2、系统的<BEGIN_E>工作频率<END_E>在很大程度上决定了<BEGIN_E>ARM<END_E>微处理器的处理能力
<BEGIN_E>ARM<END_E>7系列<BEGIN_E>微处理器<END_E>的典型处理速度为0.9MIPS/MHz
常见的<BEGIN_E>ARM<END_E>7芯片系统主时钟为20MHz-133MHz
<BEGIN_E>ARM<END_E>9系列微处理器的典型处理速度为1.1MIPS/MHz
常见的<BEGIN_E>ARM<END_E>9的系统主<BEGIN_E>时钟频率<END_E>为100MHz-
<BEGIN_E>ARM<END_E>10最高可以达到700MHz.不同芯片对时钟的处理不同
有的芯片内部时钟控制器可以分别为<BEGIN_E>ARM<END_E>
3、大多数的<BEGIN_E>ARM<END_E>微处理器片内存储器的容量都不太大
4、片内外围电路的选择除<BEGIN_E>ARM<END_E>微处理器核以外
几乎所有的<BEGIN_E>ARM<END_E>芯片均根据各自不同的应用领域
<BEGIN_E>诺基亚<END_E>
<BEGIN_E>诺基亚N86<END_E>
<BEGIN_E>诺基亚N8<END_E>
<BEGIN_E>诺基亚5230<END_E>
<BEGIN_E>摩托罗拉XT702<END_E>
<BEGIN_E>摩托罗拉ME501<END_E>
搭载<BEGIN_E>ARM<END_E>芯片架构的设备数量是英特尔的25倍
全世界99%的智能手机和平板电脑都采用<BEGIN_E>ARM<END_E>架构
约有43亿人每天都会触摸一台搭载<BEGIN_E>ARM<END_E>芯片的设备
所有的iPhone和iPad都使用<BEGIN_E>ARM<END_E>的芯片
<BEGIN_E>ARM<END_E>的营收可以用少得可怜来形容
<BEGIN_E>ARM<END_E>网络阵营成员主要包括博通、Cavium和Freescale
大部分领先的网络/电信制造商正积极地将其下一代平台迁移到<BEGIN_E>ARM<END_E>平台上来
<BEGIN_E>ARM<END_E>在行业中将扮演一个极为重要的角色
<BEGIN_E>存储器<END_E>（Memory）是现代信息技术中用于保存信息的记忆设备
只要能保存二进制数据的都可以是<BEGIN_E>存储器<END_E>；在集成电路中
一个没有实物形式的具有存储功能的电路也叫<BEGIN_E>存储器<END_E>
具有实物形式的存储设备也叫<BEGIN_E>存储器<END_E>
包括输入的原始数据、计算机程序、中间运行结果和最终运行结果都保存在<BEGIN_E>存储器<END_E>中
它根据<BEGIN_E>控制器<END_E>指定的位置存入和取出信息
有了<BEGIN_E>存储器<END_E>
计算机中的<BEGIN_E>存储器<END_E>按用途<BEGIN_E>存储器<END_E>可分为主<BEGIN_E>存储器<END_E>（内存）和辅助<BEGIN_E>存储器<END_E>（外存）
也有分为外部<BEGIN_E>存储器<END_E>和内部<BEGIN_E>存储器<END_E>的分类方法
<BEGIN_E>存储器<END_E>的主要功能是存储程序和各种<BEGIN_E>存储器<END_E>(16张)数据
<BEGIN_E>存储器<END_E>是具有“记忆”功能的设备
在计算机中采用只有两个<BEGIN_E>数码<END_E>“0”和“1”的二进制来表示数据
日常使用的十进制数必须转换成等值的<BEGIN_E>二进制数<END_E>才能存入<BEGIN_E>存储器<END_E>中
也要转换成<BEGIN_E>二进制代码<END_E>才能存储和操作
<BEGIN_E>存储器<END_E>：存放程序和数据的器件
是<BEGIN_E>存储器<END_E>最小的存储单位
<BEGIN_E>存储字<END_E>：一个数（n位二进制位）作为一个整体存入或取出时
<BEGIN_E>存储单元<END_E>：存放一个存储字的若干个记忆单元组成一个存储单元
<BEGIN_E>存储单元地址：<END_E>存储单元的编号
<BEGIN_E>寻址<END_E>：由地址寻找数据
<BEGIN_E>存储器<END_E>层次框图
<BEGIN_E>存储器<END_E>构成<BEGIN_E>存储器<END_E>的存储介质
<BEGIN_E>存储元<END_E>
然后再由许多存储单元组成一个<BEGIN_E>存储器<END_E>
一个<BEGIN_E>存储器<END_E>包含许多存储单元
每个存储单元可存放一个<BEGIN_E>字节<END_E>（按字节<BEGIN_E>编址<END_E>）
一个<BEGIN_E>存储器<END_E>中所有存储单元可存放数据的总和称为它的<BEGIN_E>存储容量<END_E>
假设一个<BEGIN_E>存储器<END_E>的<BEGIN_E>地址码<END_E>由20位二进制数（即5位<BEGIN_E>十六进制数<END_E>）组成
则该<BEGIN_E>存储器<END_E>的存储容量为1MB
这里只介绍动态<BEGIN_E>存储器<END_E>(工作原理DRAM)的工作原理
动态<BEGIN_E>存储器<END_E>每片只有一条输入<BEGIN_E>数据线<END_E>
而<BEGIN_E>地址<END_E><BEGIN_E>引脚<END_E>只有8条
借助芯片内部的行<BEGIN_E>锁存器<END_E>、列锁存器和译码电路选定芯片内的存储单元
CPU首先将<BEGIN_E>行地址<END_E>加在A0-A7上
则在CAS有效期间<BEGIN_E>数据输出<END_E>并保持
行列地址先后将R<BEGIN_E>存储器<END_E>芯片AS和CAS锁存在芯片内部
由于<BEGIN_E>电容<END_E>不可能长期保持<BEGIN_E>电荷<END_E>不变
必须定时对<BEGIN_E>动态存储<END_E><BEGIN_E>电路<END_E>的各存储单元执行重读操作
这个过程称为动态<BEGIN_E>存储器<END_E>刷新
该请求加在DMA<BEGIN_E>控制器<END_E>的0<BEGIN_E>通道<END_E>上
当DMA控制器0通道的请求得到<BEGIN_E>响应<END_E>时
对动态<BEGIN_E>存储器<END_E>执行读操作
